# JUDGE-GATED ORCHESTRATOR - COMPLETE PACKAGE
# Version: 1.0 (888 LOC, refactored Oct 2025)
# Purpose: Autonomous AI execution protocol with quality gates

===============================================================================
SECTION 1: DOCUMENTATION
===============================================================================

--- README.md ---
# Gated Phase Protocol

**Autonomous AI execution with quality gates. Works in your terminal with Claude Code, Cursor, or any AI coding assistant.**

## What Is This?

A **protocol** for autonomous execution—not a framework you import, but file conventions you follow.

Like Git tracks code changes through `.git/`, `HEAD`, and commit messages, this protocol tracks autonomous work through:
- **`.repo/briefs/CURRENT.json`** - Points to current phase
- **`.repo/plan.yaml`** - Defines phases and quality gates
- **`.repo/critiques/<phase>.{md,OK}`** - Judge feedback

Any tool that follows these conventions can participate. This repo includes a reference implementation in Python, but you could rewrite it in Bash, Rust, or Make.

## Why It Matters

**The problem:** AI agents drift off-task, skip tests, ignore scope boundaries, and require constant supervision.

**The solution:** Define phases with quality gates. Judge blocks progression until all gates pass. Agent iterates until approved, then advances autonomously.

**Result:** You define a 6-week roadmap, go to sleep, wake up to 2-3 completed phases with tests passing and docs updated.

## Key Features

✅ **Autonomous execution** - Agent works through phases without supervision
✅ **Quality enforcement** - Tests, docs, drift prevention, optional LLM review
✅ **Context-window proof** - All state in files, `./orient.sh` recovers context in <10 seconds
✅ **Terminal-native** - No servers, no APIs, just files and shell commands
✅ **Language-agnostic** - File-based protocol works for any language
✅ **5-minute setup** - Clone, `pip install -r requirements.txt`, run demo

## When to Use

✅ **Multi-phase projects** - Breaking work into 3+ sequential phases
✅ **Overnight autonomous work** - Agent executes while you sleep
✅ **Quality-critical code** - Need tests + docs enforced automatically
✅ **AI-assisted development** - Claude Code, Cursor, Windsurf, etc.
✅ **Scope control** - Prevent drift and "drive-by" changes

## When NOT to Use

❌ **Single tasks** - Just prompt Claude directly
❌ **No quality requirements** - Gates add overhead
❌ **Exploratory coding** - Rigid phases slow down discovery
❌ **Non-git projects** - Drift prevention requires git

## Quick Demo (30 Seconds)

```bash
# Clone
git clone https://github.com/PM-Frontier-Labs/judge-gated-orchestrator.git
cd judge-gated-orchestrator

# Install
pip install -r requirements.txt

# See status
./orient.sh

# Try the review flow
./tools/phasectl.py review P02-impl-feature
# → Shows diff summary, runs tests, invokes judge, shows result
```

**What you'll see:** System catches out-of-scope changes, enforces gates, provides clear feedback.

## How It Compares

| Feature | This Protocol | Aider | LangGraph | Manual Prompting |
|---------|---------------|-------|-----------|------------------|
| **Quality gates** | ✅ Enforced | ❌ | ❌ | ❌ |
| **Drift prevention** | ✅ Enforced | ❌ | ❌ | ❌ |
| **Context-window proof** | ✅ File-based | ⚠️ Partial | ❌ | ❌ |
| **Autonomous multi-phase** | ✅ Built-in | ❌ | ⚠️ Complex | ❌ |
| **Language-agnostic** | ✅ Protocol | ✅ | ❌ Python | ✅ |
| **Setup time** | 5 min | 2 min | 30 min | 0 min |
| **Overnight execution** | ✅ Proven | ❌ | ⚠️ Possible | ❌ |

**Unique position:** Only solution that enforces quality gates + prevents drift + works autonomously across context windows.

## What Gets Enforced

**Implemented gates:**

| Gate | What It Checks | Example |
|------|----------------|---------|
| **tests** | Test suite passes | `pytest` exit code must be 0 |
| **lint** | Static analysis | `ruff check .` exit code must be 0 |
| **docs** | Files updated | `README.md` must be modified |
| **drift** | Scope boundaries | Only `src/mvp/**` can change |
| **llm_review** | Semantic quality | Claude reviews architecture |

Gates are configurable per phase. Enforce what matters for your project.

## Core Workflow

```
1. Claude reads brief (.repo/briefs/P01-scaffold.md)
2. Claude implements files within scope
3. Claude runs: ./tools/phasectl.py review P01-scaffold
   ├─> Shows diff summary (in-scope vs out-of-scope)
   ├─> Runs tests
   ├─> Invokes judge
   └─> Judge checks all gates
4. Judge writes:
   ├─> .repo/critiques/P01-scaffold.md (if issues)
   └─> .repo/critiques/P01-scaffold.OK (if approved)
5. If approved: ./tools/phasectl.py next → advance
   If critique: fix issues → re-run review
```

**The key:** Judge blocks until quality standards met. Agent iterates automatically.

## Real-World Usage

**Scenario:** 6-phase backend refactor

**Setup (you):**
- Write `.repo/plan.yaml` with 6 phases
- Write 6 briefs describing what to build
- Define scope + gates for each phase

**Execution (Claude Code):**
- Reads P01 brief
- Implements changes
- Submits review, gets critique, fixes, re-submits, approved
- Advances to P02
- Repeats for all 6 phases

**Result:** Wake up to completed refactor, all tests passing, docs updated, no drift.

## File Structure

```
judge-gated-orchestrator/
├── .repo/
│   ├── briefs/           # Phase instructions
│   │   ├── CURRENT.json  # → Points to active phase
│   │   ├── P01-scaffold.md
│   │   └── P02-impl-feature.md
│   ├── critiques/        # Judge feedback
│   │   ├── P01-scaffold.OK (approved)
│   │   └── P02-impl-feature.md (needs fixes)
│   ├── traces/           # Test output
│   └── plan.yaml         # Roadmap + gates
├── tools/
│   ├── phasectl.py       # Controller (review/next)
│   ├── judge.py          # Gate validator
│   └── llm_judge.py      # Optional LLM review
├── orient.sh             # Status in 10 seconds
└── README.md             # This file
```

**For humans:** Read this file
**For LLMs:** Read `PROTOCOL.md`
**To validate:** Read `TESTME.md`

## Next Steps

### For Humans Evaluating This

1. **Try the demo:** Follow "Quick Demo" above (30 seconds)
2. **Read the protocol:** See `PROTOCOL.md` for detailed specs
3. **Test it:** Follow `TESTME.md` validation steps
4. **Implement your own phases:** Replace demo with your roadmap

### For Claude Code / AI Agents

Read `PROTOCOL.md` for execution instructions. That file contains the operational manual for working in this protocol.

### For CI/CD Integration

The protocol is just files + shell commands. Easy to integrate:
```bash
./tools/phasectl.py review $PHASE_ID
if [ $? -eq 0 ]; then
  echo "Phase approved"
  ./tools/phasectl.py next
fi
```

## Philosophy

**This is a protocol, not a framework.**

You don't install it, you follow it. You don't import classes, you write files that match the conventions. You don't learn an API, you run shell commands.

Like Git doesn't tell you how to write code—just how to track changes—this protocol doesn't tell you what to build, just how to enforce quality during autonomous execution.

**The protocol is the spec. This repo is one way to implement it.**

## Get Started

```bash
git clone https://github.com/PM-Frontier-Labs/judge-gated-orchestrator.git
cd judge-gated-orchestrator
pip install -r requirements.txt
./orient.sh
```

Then read `PROTOCOL.md` to start working.

## License

MIT

--- PROTOCOL.md ---
# Gated Phase Protocol - LLM Operational Manual

**Audience:** AI coding assistants (Claude Code, Cursor, Windsurf, etc.)

**Purpose:** Precise execution instructions for autonomous work under quality gates.

---

## Protocol Overview

This is a **file-based protocol** for autonomous execution with quality gates. You will:

1. Read a phase brief defining scope and objectives
2. Implement changes within that scope
3. Submit for review to a judge
4. Handle feedback and iterate until approved
5. Advance to next phase and repeat

**All state lives in files.** No memory required. You can recover full context anytime via `./orient.sh`.

---

## Core Loop

```
1. Orient:     ./orient.sh
2. Read brief: cat .repo/briefs/<phase-id>.md
3. Implement:  Make changes within scope
4. Review:     ./tools/phasectl.py review <phase-id>
5. Check:      If .repo/critiques/<phase-id>.OK exists → approved
               If .repo/critiques/<phase-id>.md exists → fix and re-review
6. Advance:    ./tools/phasectl.py next
7. Repeat from step 1
```

---

## File Specifications

### `.repo/briefs/CURRENT.json`

Points to the active phase.

**Format:**
```json
{
  "phase_id": "P01-scaffold",
  "brief_path": ".repo/briefs/P01-scaffold.md",
  "status": "active",
  "started_at": 1760223767.0468428
}
```

**Fields:**
- `phase_id` (string): Phase identifier matching plan.yaml
- `brief_path` (string): Relative path to phase brief
- `status` (string): Always "active" for current phase
- `started_at` (float): Unix timestamp when phase started

**Read this first** when recovering context.

---

### `.repo/plan.yaml`

Defines roadmap, phases, scope, and quality gates.

**Format:**
```yaml
plan:
  id: PROJECT-ID
  summary: "Short description of overall goal"
  base_branch: "main"
  test_command: "pytest tests/ -v"  # Optional, defaults to pytest
  lint_command: "ruff check ."      # Optional, defaults to ruff

  phases:
    - id: P01-phase-name
      description: "What this phase accomplishes"

      scope:
        include: ["src/module/**", "tests/module/**"]
        exclude: ["src/**/legacy/**"]

      artifacts:
        must_exist: ["src/module/file.py", "tests/test_file.py"]

      gates:
        tests: { must_pass: true }
        lint:  { must_pass: true }
        docs: { must_update: ["docs/module.md"] }
        drift: { allowed_out_of_scope_changes: 0 }
        llm_review: { enabled: false }

      drift_rules:
        forbid_changes: ["requirements.txt", "pyproject.toml"]
```

**Key sections:**
- **scope.include**: Glob patterns defining files you MAY modify
- **scope.exclude**: Patterns within include to exclude
- **artifacts.must_exist**: Files that must exist after implementation
- **gates**: Quality checks enforced by judge
- **drift_rules.forbid_changes**: Files that absolutely cannot change

**The judge validates all gates before approval.**

---

### `.repo/briefs/<phase-id>.md`

Phase-specific implementation instructions.

**Typical structure:**
```markdown
# Phase <ID>: <Name>

## Objective
What to accomplish

## Scope 🎯
✅ YOU MAY TOUCH: [list]
❌ DO NOT TOUCH: [list]
🤔 IF YOU NEED TO TOUCH THESE: Stop and create separate phase

## Required Artifacts
- [ ] file1.py - Description
- [ ] file2.py - Description

## Gates
- Tests: Must pass
- Docs: Must update [file]
- Drift: N out-of-scope changes allowed

## Implementation Steps
1. Step one
2. Step two
...
```

**Read the entire brief** before making any changes.

---

### `.repo/critiques/<phase-id>.md`

Judge feedback when phase needs revision.

**Format:**
```markdown
# Critique: P01-scaffold

## Issues Found

- Out-of-scope changes detected (3 files, 0 allowed):
  - tools/judge.py
  - README.md
  - requirements.txt

Options to fix:
1. Revert: git checkout HEAD tools/judge.py README.md requirements.txt
2. Update phase scope in .repo/briefs/P01-scaffold.md
3. Split into separate phase

- Tests failed with exit code 1. See .repo/traces/last_test.txt

## Resolution

Please address the issues above and re-run:
```
./tools/phasectl.py review P01-scaffold
```
```

**When this file exists:**
1. Read it completely
2. Fix all issues listed
3. Re-run `./tools/phasectl.py review <phase-id>`
4. Repeat until `.repo/critiques/<phase-id>.OK` appears

---

### `.repo/critiques/<phase-id>.OK`

Approval marker. Phase passed all gates.

**Format:**
```
Phase P01-scaffold approved at 1760223767.123
```

**When this file exists:**
- Phase is approved
- You may run `./tools/phasectl.py next` to advance

---

### `.repo/traces/last_test.txt`

Test execution results.

**Format:**
```
Exit code: 0
Timestamp: 1760232719.972681

=== STDOUT ===
[test runner output]

=== STDERR ===
[error output if any]
```

**Read this when tests fail** to understand what broke.

---

## Scope Rules and Drift Prevention

**The judge enforces scope boundaries using git diff.**

### Include/Exclude Patterns

From plan.yaml:
```yaml
scope:
  include: ["src/mvp/**", "tests/mvp/**"]
  exclude: ["src/**/legacy/**"]
```

**Matching rules:**
- Uses `fnmatch` (shell-style glob patterns)
- `**` matches multiple directory levels
- `*` matches anything in one level
- File must match `include` AND NOT match `exclude`

**Example:**
- `src/mvp/feature.py` → ✅ In scope
- `src/mvp/legacy/old.py` → ❌ Excluded
- `tools/judge.py` → ❌ Not in include patterns

### Drift Detection

Judge runs:
```bash
# Uncommitted changes
git diff --name-only HEAD

# Committed changes from base branch
git merge-base HEAD main
git diff --name-only <merge-base>...HEAD
```

**Then classifies each file:**
- If matches scope.include AND NOT scope.exclude → in-scope
- Otherwise → out-of-scope

**Drift gate:**
```yaml
drift:
  allowed_out_of_scope_changes: 0
```

If `out_of_scope_count > allowed`, review fails.

### Forbidden Changes

From plan.yaml:
```yaml
drift_rules:
  forbid_changes: ["requirements.txt", "pyproject.toml"]
```

**If ANY forbidden file changes, review fails immediately.**

Use this for files that require separate dedicated phases (dependencies, CI config, etc.).

---

## Quality Gates

Judge checks these in order:

### 1. Artifacts Gate

```yaml
artifacts:
  must_exist: ["src/module/file.py", "tests/test_file.py"]
```

**Check:** Files exist and are not empty

**Fails if:** Any file missing or zero bytes

### 2. Tests Gate

```yaml
gates:
  tests: { must_pass: true }
```

**Check:** Test runner exit code == 0

**Test command:** From plan.yaml `test_command`, defaults to `pytest tests/ -v`

**Fails if:** Exit code != 0

**See:** `.repo/traces/last_test.txt` for details

### 3. Lint Gate (Optional)

```yaml
gates:
  lint: { must_pass: true }
```

**Check:** Linter exit code == 0

**Lint command:** From plan.yaml `lint_command`, defaults to `ruff check .`

**Fails if:** Exit code != 0

**See:** `.repo/traces/last_lint.txt` for details

### 4. Docs Gate

```yaml
gates:
  docs: { must_update: ["docs/module.md"] }
```

**Check:** Files exist and are not empty

**Fails if:** Any doc missing or zero bytes

**Note:** Supports section anchors like `docs/module.md#feature` (checks base file)

### 5. Drift Gate

```yaml
gates:
  drift: { allowed_out_of_scope_changes: 0 }
```

**Check:** Out-of-scope file count <= allowed

**Fails if:** More out-of-scope changes than allowed

**See:** "Scope Rules" section above

### 6. LLM Review Gate (Optional)

```yaml
gates:
  llm_review: { enabled: true }
```

**Check:** Claude reviews changed files for architecture issues

**Requires:** `ANTHROPIC_API_KEY` environment variable

**Fails if:** LLM finds issues or API key missing

**Reviews only:** Files changed in `git diff --name-only HEAD`

---

## Commands Reference

### `./orient.sh`

**Purpose:** Recover full context in 10 seconds

**Shows:**
- Current phase ID
- Progress (X/Y phases complete)
- Status (approved/needs-fixes/in-progress)
- Next steps

**Run this:**
- After context window exhaustion
- When starting new session
- When you're confused about state

**Example output:**
```
🎯 Current Phase: P02-impl-feature (2/2)

📊 Progress:
✅ P01-scaffold (approved)
⚠️  P02-impl-feature (needs fixes)

📄 Current Brief:
.repo/briefs/P02-impl-feature.md

🔍 Status:
Critique exists: .repo/critiques/P02-impl-feature.md

⏭️  Next Steps:
1. Read critique: cat .repo/critiques/P02-impl-feature.md
2. Fix issues
3. Re-submit: ./tools/phasectl.py review P02-impl-feature
```

### `./tools/phasectl.py review <phase-id>`

**Purpose:** Submit phase for judge review

**What it does:**
1. Shows diff summary (in-scope vs out-of-scope files)
2. Runs test command from plan.yaml
3. Saves results to `.repo/traces/last_test.txt`
4. Invokes judge to check all gates
5. Produces either `.repo/critiques/<phase-id>.md` or `.repo/critiques/<phase-id>.OK`

**Exit codes:**
- `0` - Approved (`.OK` file created)
- `1` - Needs revision (`.md` critique created)
- `2` - Error (judge couldn't run)

**Example:**
```bash
./tools/phasectl.py review P02-impl-feature
```

### `./tools/phasectl.py next`

**Purpose:** Advance to next phase

**What it does:**
1. Checks current phase is approved (`.OK` file exists)
2. Finds next phase in plan.yaml
3. Updates `.repo/briefs/CURRENT.json` to point to next phase
4. Shows path to next brief

**Exit codes:**
- `0` - Advanced successfully or all phases complete
- `1` - Error (current phase not approved, next brief missing, etc.)

**Example:**
```bash
./tools/phasectl.py next
# Output:
# ➡️  Advanced to phase P03-refactor
# 📄 Brief: .repo/briefs/P03-refactor.md
```

**Only run this after** `.repo/critiques/<phase-id>.OK` exists.

---

## Error Handling and Recovery

### Tests Failing

**Symptom:** Review fails with "Tests failed with exit code 1"

**Recovery:**
1. Read `.repo/traces/last_test.txt`
2. Find failing test in STDOUT/STDERR
3. Fix the code or test
4. Re-run `./tools/phasectl.py review <phase-id>`

### Out-of-Scope Changes

**Symptom:** Review fails with "Out-of-scope changes detected"

**Recovery options:**

**Option 1 - Revert:**
```bash
git checkout HEAD file1.py file2.py
./tools/phasectl.py review <phase-id>
```

**Option 2 - Update scope:**
Edit `.repo/briefs/<phase-id>.md` and plan.yaml to include the files, then re-review.

**Option 3 - Split phase:**
Create a new phase for the out-of-scope work after current phase completes.

### Forbidden Files Changed

**Symptom:** "Forbidden files changed"

**Recovery:**
```bash
git checkout HEAD requirements.txt pyproject.toml
./tools/phasectl.py review <phase-id>
```

**Never change forbidden files** without creating a dedicated phase.

### LLM Review Failures

**Symptom:** "LLM review enabled but ANTHROPIC_API_KEY not set"

**Recovery:**
```bash
export ANTHROPIC_API_KEY="sk-ant-..."
./tools/phasectl.py review <phase-id>
```

Or disable LLM review in plan.yaml if not needed.

### Missing Artifacts

**Symptom:** "Missing required artifact: src/module/file.py"

**Recovery:**
1. Create the missing file
2. Ensure it's not empty
3. Re-run review

### Context Window Exhausted

**Symptom:** You lost track of what you were doing

**Recovery:**
```bash
./orient.sh  # Shows current state
cat .repo/briefs/CURRENT.json  # Current phase
cat .repo/briefs/<phase-id>.md  # What to do
```

**All state is in files.** You can always recover.

---

## Execution Best Practices

### 1. Always Read the Brief First

```bash
cat .repo/briefs/<phase-id>.md
```

Understand scope boundaries before writing any code.

### 2. Check Scope Explicitly

From the brief, identify:
- ✅ Files you MAY touch
- ❌ Files you must NOT touch
- 🤔 Files that need separate phase

**If you need something out of scope:** Stop. Create a follow-up phase.

### 3. Run Review Early

Don't wait until "done" to run review. Run it when you think you're close:

```bash
./tools/phasectl.py review <phase-id>
```

**Diff summary shows:** In-scope vs out-of-scope changes before judge runs.

**Early feedback helps:** Catch drift before writing more code.

### 4. Read Critiques Completely

When `.repo/critiques/<phase-id>.md` appears:
1. Read ALL issues (don't just fix the first one)
2. Fix them all
3. Re-review once

**Don't iterate issue-by-issue.** Fix everything in one pass.

### 5. Commit Often (If Needed)

The judge uses git diff to detect changes. You can:
- Work with uncommitted changes (judge sees them)
- Commit incrementally (judge sees diff from base branch)

**Either works.** Judge combines both.

### 6. Trust the Gates

If review passes, **all gates passed:**
- Tests ran and passed
- Docs were updated
- Scope was respected
- LLM approved (if enabled)

**No manual double-checking needed.** Judge is authoritative.

### 7. Use Orient When Lost

```bash
./orient.sh
```

Shows exactly what to do next.

---

## Multi-Phase Workflow Example

**Scenario:** 3-phase refactor

**Setup:**
- P01: Scaffold new module
- P02: Implement core feature
- P03: Refactor + optimize

**Execution:**

```bash
# Start
./orient.sh
# → Shows P01-scaffold is current phase

# Read brief
cat .repo/briefs/P01-scaffold.md
# → Scope: src/mvp/**, tests/mvp/**, docs/mvp.md

# Implement
# ... create src/mvp/__init__.py
# ... create tests/mvp/test_golden.py
# ... create docs/mvp.md

# Review
./tools/phasectl.py review P01-scaffold
# → Shows diff summary
# → Runs tests
# → Judge checks gates
# → Creates .repo/critiques/P01-scaffold.OK ✅

# Advance
./tools/phasectl.py next
# → Updates CURRENT.json to P02-impl-feature

# Read next brief
cat .repo/briefs/P02-impl-feature.md
# → Scope: src/mvp/feature.py, tests/mvp/test_feature.py

# Implement
# ... create src/mvp/feature.py
# ... create tests/mvp/test_feature.py
# ... accidentally edit tools/judge.py (drift!)

# Review
./tools/phasectl.py review P02-impl-feature
# → Diff summary: ❌ Out of scope (1 file)
# → Judge creates critique

# Read critique
cat .repo/critiques/P02-impl-feature.md
# → "Out-of-scope changes: tools/judge.py"
# → "Fix: git checkout HEAD tools/judge.py"

# Fix
git checkout HEAD tools/judge.py

# Re-review
./tools/phasectl.py review P02-impl-feature
# → All gates pass ✅

# Advance
./tools/phasectl.py next
# → Updates to P03-refactor

# ... continue for P03
```

**Result:** 3 phases completed, each validated, no drift.

---

## What Happens During Review

Detailed breakdown of `./tools/phasectl.py review <phase-id>`:

**Step 1: Diff Summary**
- Runs `git diff --name-only HEAD` (uncommitted)
- Runs `git diff --name-only <merge-base>...HEAD` (committed)
- Combines both lists
- Classifies each file as in-scope or out-of-scope
- Shows:
  ```
  📊 Change Summary:
  ✅ In scope (3 files):
    - src/mvp/feature.py
    - tests/mvp/test_feature.py
    - docs/mvp.md

  ❌ Out of scope (1 file):
    - tools/judge.py

  ⚠️  Drift limit: 0 files allowed, 1 found
  ```

**Step 2: Run Tests**
- Gets test command from plan.yaml (defaults to `pytest tests/ -v`)
- Checks if test runner installed
- Runs tests
- Saves stdout/stderr to `.repo/traces/last_test.txt`
- Continues even if tests fail (judge will catch it)

**Step 3: Invoke Judge**
- Runs `./tools/judge.py <phase-id>`
- Judge performs 5 checks (artifacts, tests, docs, drift, LLM)
- Each check returns list of issues
- If any issues found → writes `.repo/critiques/<phase-id>.md`
- If zero issues → writes `.repo/critiques/<phase-id>.OK`

**Step 4: Show Verdict**
- If `.OK` exists: "✅ Phase approved!"
- If `.md` exists: "❌ Phase needs revision:" + shows critique
- Exit with appropriate code (0=approved, 1=critique, 2=error)

---

## File-Based State Management

**Why files?**
- **Context-window proof:** All state recoverable from disk
- **No memory needed:** New instance can resume work instantly
- **Debuggable:** `ls .repo/critiques/` shows status
- **Version controlled:** Git tracks all state changes
- **Tool-agnostic:** Any tool can read/write these files

**What's NOT in files:**
- Nothing. Everything is on disk.

**Recovery from any state:**
1. `./orient.sh` → See current phase and status
2. `cat .repo/briefs/CURRENT.json` → Get phase ID
3. `cat .repo/briefs/<phase-id>.md` → Read instructions
4. `ls .repo/critiques/` → Check if approved or needs fixes
5. Resume work

**No exceptions. No hidden state. No surprises.**

---

## When to Create New Phases

**Create a new phase when:**

1. **Out-of-scope changes needed**
   - Current scope doesn't allow the files you need to change
   - Judge will block you with drift errors
   - Solution: Create a phase after current one with correct scope

2. **Forbidden files need changes**
   - `requirements.txt`, `pyproject.toml`, CI configs
   - These typically require dedicated phases
   - Keeps dependency changes isolated and reviewable

3. **Work crosses multiple modules**
   - Each phase should have cohesive scope
   - If refactoring 3 modules, consider 3 phases
   - Easier to review, easier to rollback

4. **Testing strategy changes**
   - Phase 1: Implement feature
   - Phase 2: Add integration tests
   - Separate concerns, separate gates

5. **High-risk changes**
   - Database migrations
   - API contract changes
   - Give these dedicated phases with strict gates

**Don't create phases for:**
- Minor tweaks within current scope
- Documentation updates in-scope
- Test fixes for current feature

**When in doubt:** Can this be reviewed as one cohesive change? If yes → same phase. If no → new phase.

---

## LLM Review Details

**When enabled:**
```yaml
gates:
  llm_review: { enabled: true }
```

**What it does:**
1. Runs `git diff --name-only HEAD` to find changed files
2. Reads each changed file's content
3. Sends to Claude with this prompt:
   ```
   Review this code for architecture issues, bugs, or anti-patterns.
   Focus on: correctness, maintainability, performance, security.
   If you find issues, list them clearly.
   If code looks good, respond "LGTM".
   ```
4. Parses response
5. If issues found → adds to critique
6. If "LGTM" → gate passes

**Requirements:**
- `ANTHROPIC_API_KEY` environment variable
- `anthropic` Python package installed

**Costs:**
- ~$0.01-0.10 per review depending on file count/size
- Only reviews changed files (not all in-scope files)

**When to use:**
- High-stakes code (security, payments, data migrations)
- Autonomous overnight execution (extra validation)
- Learning projects (get feedback on approach)

**When to skip:**
- Low-risk changes
- Cost-sensitive projects
- You prefer manual review

---

## This Protocol vs Frameworks

**This is a protocol, not a framework.**

You don't install it, you follow it.

**What that means:**

**Frameworks:**
- Import classes: `from framework import Agent`
- Learn API: `agent.run(task)`
- Dependency: `pip install framework`

**This protocol:**
- Follow conventions: `.repo/briefs/CURRENT.json`
- Run commands: `./tools/phasectl.py review P01`
- No imports: Just files and shell scripts

**Like Git:**
- Git doesn't dictate your code
- Git defines conventions (`.git/`, `HEAD`, commits)
- Tools follow those conventions
- This protocol is the same

**You could:**
- Rewrite `phasectl.py` in Bash
- Rewrite `judge.py` in Rust
- Use Make instead of Python

**As long as:**
- You write `.repo/briefs/CURRENT.json` correctly
- You read `plan.yaml` correctly
- You create `.repo/critiques/<phase-id>.OK` on approval

**The protocol is the spec. This repo is one implementation.**

---

## Quick Command Cheat Sheet

```bash
# Recover context
./orient.sh

# Check current phase
cat .repo/briefs/CURRENT.json

# Read current brief
cat .repo/briefs/$(jq -r .phase_id < .repo/briefs/CURRENT.json).md

# Submit for review
./tools/phasectl.py review <phase-id>

# Check if approved
ls .repo/critiques/<phase-id>.OK

# Read critique if failed
cat .repo/critiques/<phase-id>.md

# Advance to next phase
./tools/phasectl.py next

# See test results
cat .repo/traces/last_test.txt

# Check diff before review
git diff --name-only HEAD
```

---

## Summary

**The protocol in one sentence:**

Read brief → Implement within scope → Review with judge → Fix issues → Advance → Repeat until roadmap complete.

**Key principles:**
1. All state in files (context-window proof)
2. Judge enforces gates (quality guaranteed)
3. Scope boundaries prevent drift (focus maintained)
4. Autonomous execution (overnight work possible)
5. Protocol, not framework (simple, replaceable)

**Your job as an LLM agent:**
1. Follow the brief exactly
2. Respect scope boundaries
3. Submit for review when done
4. Fix critiques completely
5. Advance only when approved

**The judge's job:**
1. Enforce quality gates
2. Prevent scope drift
3. Block progression until all gates pass
4. Provide actionable feedback

**Together:** You get autonomous multi-phase execution with quality guarantees.

**Start here:** `./orient.sh`

--- TESTME.md ---
# Gated Phase Protocol - Testing Guide

**Audience:** Evaluators, contributors, QA engineers

**Purpose:** Validate the protocol implementation works correctly

**Time:** 15-20 minutes for full validation

---

## Prerequisites

### Required

```bash
# Python 3.8+
python3 --version

# Git
git --version

# Clone repo
git clone https://github.com/PM-Frontier-Labs/judge-gated-orchestrator.git
cd judge-gated-orchestrator

# Install dependencies
pip install -r requirements.txt

# Verify installation
python3 -c "import yaml; print('✓ pyyaml installed')"
pytest --version
```

### Optional (for LLM review test)

```bash
# Anthropic API key
export ANTHROPIC_API_KEY="sk-ant-..."

# Verify
python3 -c "from anthropic import Anthropic; print('✓ anthropic package installed')"
```

---

## Test 1: Basic Pass Flow

**Goal:** Verify a phase can pass all gates and advance

**Steps:**

```bash
# 1. Check current state
./orient.sh
# Expected: Shows P02-impl-feature as current phase
# (P01 already completed in repo)

# 2. Verify P01 passed
ls .repo/critiques/
# Expected: P01-scaffold.OK exists

# 3. Check what P02 requires
cat .repo/briefs/P02-impl-feature.md
# Expected: Shows scope, artifacts, gates

# 4. Verify required files exist
ls src/mvp/feature.py tests/mvp/test_feature.py
# Expected: Both files exist (already implemented)

# 5. Run review
./tools/phasectl.py review P02-impl-feature
# Expected output:
#   📊 Change Summary: (may show changes)
#   🧪 Running tests...
#   ⚖️  Invoking judge...
#   Either: ✅ Phase approved OR ❌ Phase needs revision

# 6. Check critique
ls .repo/critiques/P02-impl-feature.*
# If .OK exists → test passed
# If .md exists → see "Troubleshooting" below
```

**Success criteria:**
- ✅ orient.sh runs without errors
- ✅ Tests run and show results
- ✅ Judge produces either .OK or .md file
- ✅ Feedback is actionable

**Note:** P02 may fail due to out-of-scope changes from previous work. That's expected - see Test 3.

---

## Test 2: Intentional Failure Flow

**Goal:** Verify judge catches issues and provides critique

**Steps:**

```bash
# 1. Create a branch for testing
git checkout -b test-failure-flow

# 2. Break the tests
echo "def test_broken(): assert False" >> tests/mvp/test_feature.py

# 3. Submit for review
./tools/phasectl.py review P02-impl-feature

# Expected output:
#   📊 Change Summary: tests/mvp/test_feature.py in scope
#   🧪 Running tests...
#   ⚖️  Invoking judge...
#   ❌ Phase P02-impl-feature needs revision:
#
#   # Critique: P02-impl-feature
#   ## Issues Found
#   - Tests failed with exit code 1. See .repo/traces/last_test.txt

# 4. Verify critique exists
cat .repo/critiques/P02-impl-feature.md
# Expected: Shows "Tests failed" issue

# 5. Check test trace
cat .repo/traces/last_test.txt
# Expected: Shows pytest output with FAILED test_broken

# 6. Fix the issue
git checkout tests/mvp/test_feature.py

# 7. Re-review
./tools/phasectl.py review P02-impl-feature
# Expected: ✅ Phase approved (assuming no other issues)

# 8. Clean up
git checkout main
git branch -D test-failure-flow
```

**Success criteria:**
- ✅ Judge detected test failure
- ✅ Critique file created with actionable feedback
- ✅ Trace file shows detailed test output
- ✅ After fix, re-review passes

---

## Test 3: Drift Detection

**Goal:** Verify scope enforcement catches out-of-scope changes

**Steps:**

```bash
# 1. Create test branch
git checkout -b test-drift-detection

# 2. Check P02 scope
grep -A5 "scope:" .repo/plan.yaml | grep -A3 "P02"
# Expected: Shows include patterns (src/mvp/feature.py, tests/mvp/test_feature.py)

# 3. Make out-of-scope change
echo "# Out of scope change" >> README.md

# 4. Submit for review
./tools/phasectl.py review P02-impl-feature

# Expected output:
#   📊 Change Summary:
#
#   ❌ Out of scope (1 files):
#     - README.md
#
#   ⚠️  Drift limit: 0 files allowed, 1 found
#
#   💡 Fix options:
#      1. Revert: git checkout HEAD README.md
#      2. Update scope in .repo/briefs/P02-impl-feature.md
#      3. Split into separate phase
#
#   ⚖️  Invoking judge...
#   ❌ Phase P02-impl-feature needs revision:

# 5. Check critique
cat .repo/critiques/P02-impl-feature.md
# Expected: Contains "Out-of-scope changes detected"

# 6. Fix by reverting
git checkout HEAD README.md

# 7. Re-review
./tools/phasectl.py review P02-impl-feature
# Expected: No drift warnings

# 8. Clean up
git checkout main
git branch -D test-drift-detection
```

**Success criteria:**
- ✅ Diff summary shows out-of-scope files BEFORE judge runs
- ✅ Judge blocks approval due to drift
- ✅ Critique suggests fix options
- ✅ After revert, review passes

---

## Test 4: Forbidden Files

**Goal:** Verify forbidden file changes are blocked

**Steps:**

```bash
# 1. Create test branch
git checkout -b test-forbidden-files

# 2. Check forbidden patterns
grep -A5 "drift_rules:" .repo/plan.yaml
# Expected: Shows forbid_changes: ["requirements.txt", "pyproject.toml", ...]

# 3. Change forbidden file
echo "# Test change" >> requirements.txt

# 4. Submit for review
./tools/phasectl.py review P02-impl-feature

# Expected output:
#   📊 Change Summary:
#   ❌ Out of scope (1 files):
#     - requirements.txt
#
#   ⚖️  Invoking judge...
#   ❌ Phase needs revision:
#
#   # Critique: P02-impl-feature
#   ## Issues Found
#   - Forbidden files changed (these require a separate phase):
#     - requirements.txt
#   - Fix: git checkout HEAD requirements.txt

# 5. Verify critique
cat .repo/critiques/P02-impl-feature.md | grep -i forbidden
# Expected: Shows "Forbidden files changed"

# 6. Revert
git checkout HEAD requirements.txt

# 7. Clean up
git checkout main
git branch -D test-forbidden-files
```

**Success criteria:**
- ✅ Judge identifies forbidden file changes
- ✅ Critique explains these need separate phase
- ✅ Specific fix command provided

---

## Test 5: LLM Review (Optional)

**Goal:** Verify optional LLM code review gate

**Prerequisites:**
```bash
export ANTHROPIC_API_KEY="sk-ant-..."
pip install anthropic
```

**Steps:**

```bash
# 1. Check if P02 has LLM review enabled
grep -A10 "P02-impl-feature" .repo/plan.yaml | grep llm_review
# Expected: llm_review: { enabled: true }

# 2. Make a code change
git checkout -b test-llm-review
echo "def bad_function(): return 1/0  # Division by zero" >> src/mvp/feature.py

# 3. Submit for review
./tools/phasectl.py review P02-impl-feature

# Expected output:
#   🧪 Running tests...
#   ⚖️  Invoking judge...
#   🤖 Running LLM code review...
#   [May show LLM feedback about division by zero]
#   ❌ Phase needs revision OR ✅ approved
#   (depends on if LLM catches the issue)

# 4. If no API key set, different error
# Unset key to test
ANTHROPIC_API_KEY="" ./tools/phasectl.py review P02-impl-feature
# Expected: "LLM review enabled but ANTHROPIC_API_KEY not set"

# 5. Clean up
git checkout main
git branch -D test-llm-review
```

**Success criteria:**
- ✅ LLM review runs when enabled and key present
- ✅ Clear error when key missing
- ✅ LLM feedback is actionable (if issues found)

---

## Test 6: Phase Advancement

**Goal:** Verify phase transitions work correctly

**Steps:**

```bash
# 1. Ensure P02 is approved
# (If not, fix any issues and get it approved first)

# 2. Check current phase
cat .repo/briefs/CURRENT.json | grep phase_id
# Expected: "phase_id": "P02-impl-feature"

# 3. Try to advance without approval
rm -f .repo/critiques/P02-impl-feature.OK
./tools/phasectl.py next
# Expected: ❌ Error: Phase P02-impl-feature not yet approved

# 4. Approve phase (simulate)
./tools/phasectl.py review P02-impl-feature
# (Assuming it passes)

# 5. Advance to next phase
./tools/phasectl.py next
# Expected:
#   ➡️  Advanced to phase P03-...
#   OR
#   🎉 All phases complete!
#   (depends on plan.yaml phase count)

# 6. Verify CURRENT.json updated
cat .repo/briefs/CURRENT.json
# Expected: phase_id changed to next phase (or stayed at P02 if last)

# 7. Reset to original state
git checkout .repo/briefs/CURRENT.json .repo/critiques/
```

**Success criteria:**
- ✅ Cannot advance without approval
- ✅ Advance succeeds when approved
- ✅ CURRENT.json updates correctly
- ✅ Shows "All phases complete" if at end

---

## Test 7: Context Recovery

**Goal:** Verify orient.sh provides complete status

**Steps:**

```bash
# 1. Run orient
./orient.sh

# Expected output structure:
# 🎯 Current Phase: <phase-id> (X/Y)
#
# 📊 Progress:
# ✅ P01-scaffold (approved)
# [status] P02-impl-feature (...)
#
# 📄 Current Brief:
# .repo/briefs/<phase-id>.md
#
# 🔍 Status:
# [Approval status or critique location]
#
# ⏭️  Next Steps:
# [Actionable next steps]

# 2. Verify completeness
./orient.sh | grep -q "Current Phase" && echo "✓ Shows current phase"
./orient.sh | grep -q "Progress" && echo "✓ Shows progress"
./orient.sh | grep -q "Next Steps" && echo "✓ Shows next steps"
```

**Success criteria:**
- ✅ Shows current phase ID
- ✅ Shows progress (X/Y phases)
- ✅ Shows status (approved/critique/in-progress)
- ✅ Shows actionable next steps
- ✅ Runs in < 10 seconds

---

## Test 8: Error Handling

**Goal:** Verify graceful error handling

**Steps:**

```bash
# Test 8a: Missing plan.yaml
mv .repo/plan.yaml .repo/plan.yaml.backup
./tools/phasectl.py review P02-impl-feature
# Expected: ❌ Error: .repo/plan.yaml not found
mv .repo/plan.yaml.backup .repo/plan.yaml

# Test 8b: Invalid YAML
echo "invalid: yaml: syntax:" >> .repo/plan.yaml
./tools/phasectl.py review P02-impl-feature
# Expected: ❌ Error: Invalid YAML in .repo/plan.yaml
git checkout .repo/plan.yaml

# Test 8c: Missing brief
./tools/phasectl.py review P99-nonexistent
# Expected: ❌ Error: Phase P99-nonexistent not found in plan

# Test 8d: Missing test runner (if pytest not installed)
# (Skip if pytest is installed)
# Expected: ❌ Error: pytest not installed

# Test 8e: Malformed CURRENT.json
echo "{invalid json" > .repo/briefs/CURRENT.json
./orient.sh
# Expected: Error about invalid JSON
git checkout .repo/briefs/CURRENT.json
```

**Success criteria:**
- ✅ All error messages are clear and actionable
- ✅ No Python stack traces for expected errors
- ✅ Exit codes are appropriate (1 for errors, 0 for success)

---

## Full System Test

**Goal:** Complete workflow from scratch

**Time:** 5 minutes

**Steps:**

```bash
# 1. Reset to clean state
git checkout main
git clean -fd
rm -rf .repo/critiques/*.md .repo/critiques/*.OK
rm -rf .repo/traces/*

# 2. Start from P01
echo '{
  "phase_id": "P01-scaffold",
  "brief_path": ".repo/briefs/P01-scaffold.md",
  "status": "active",
  "started_at": '$(date +%s)'
}' > .repo/briefs/CURRENT.json

# 3. Orient
./orient.sh
# Expected: Shows P01-scaffold as current

# 4. Verify P01 files exist (already in repo)
ls src/mvp/__init__.py tests/mvp/test_golden.py docs/mvp.md
# Expected: All exist

# 5. Review P01
./tools/phasectl.py review P01-scaffold
# Expected: ✅ Approved (or shows issues to fix)

# 6. Advance to P02
./tools/phasectl.py next
# Expected: ➡️ Advanced to P02-impl-feature

# 7. Orient again
./orient.sh
# Expected: Shows P02-impl-feature as current, P01 as approved

# 8. Review P02
./tools/phasectl.py review P02-impl-feature
# Expected: ✅ Approved or ❌ shows issues

# 9. If all phases complete
./tools/phasectl.py next
# Expected: 🎉 All phases complete! (or advances to P03 if exists)
```

**Success criteria:**
- ✅ Complete flow works without manual intervention
- ✅ Each phase gates correctly
- ✅ Can advance through all phases
- ✅ Orient always shows correct state

---

## Troubleshooting

### P02 fails with out-of-scope changes

**Problem:** README.md, tools/judge.py, or other files show as out-of-scope

**Cause:** Previous development changes not reverted

**Fix:**
```bash
git status
git checkout HEAD <out-of-scope-files>
./tools/phasectl.py review P02-impl-feature
```

### Tests fail on fresh clone

**Problem:** `pytest` shows failures

**Cause:** Missing dependencies or environment issue

**Fix:**
```bash
pip install -r requirements.txt
python3 -m pytest tests/ -v
# Debug specific failures
```

### LLM review not working

**Problem:** "ANTHROPIC_API_KEY not set"

**Fix:**
```bash
export ANTHROPIC_API_KEY="sk-ant-..."
# OR disable in plan.yaml:
# llm_review: { enabled: false }
```

### orient.sh shows wrong phase

**Problem:** CURRENT.json out of sync

**Fix:**
```bash
cat .repo/briefs/CURRENT.json
# Manually verify phase_id matches plan.yaml
# Reset if needed
```

### Judge produces no output

**Problem:** No .OK or .md file created

**Cause:** Exception in judge.py

**Fix:**
```bash
python3 tools/judge.py P02-impl-feature
# Check for Python errors
```

---

## Validation Checklist

Use this to verify the system is production-ready:

**Core Functionality:**
- [ ] Orient shows complete status in < 10 seconds
- [ ] Review command runs tests and invokes judge
- [ ] Judge enforces all enabled gates
- [ ] Critiques are actionable and specific
- [ ] Approval markers created when all gates pass
- [ ] Next command advances phases correctly

**Quality Gates:**
- [ ] Tests gate catches test failures
- [ ] Docs gate catches missing documentation
- [ ] Drift gate catches out-of-scope changes
- [ ] Drift gate respects include/exclude patterns
- [ ] Forbidden files are blocked
- [ ] LLM review works when enabled (optional)

**Error Handling:**
- [ ] Missing files produce clear errors
- [ ] Invalid YAML produces clear errors
- [ ] Missing dependencies produce clear errors
- [ ] All errors include fix suggestions

**Context Recovery:**
- [ ] All state stored in files (no hidden state)
- [ ] Orient recovers full context from files
- [ ] Can resume work after context window exhaustion
- [ ] CURRENT.json always accurate

**Documentation:**
- [ ] README.md clear for humans evaluating
- [ ] PROTOCOL.md complete for LLM execution
- [ ] TESTME.md (this file) validates system
- [ ] All docs accurate and up-to-date

---

## Success Criteria

**The protocol implementation is valid if:**

1. ✅ All 8 tests pass without modification
2. ✅ Full system test completes successfully
3. ✅ Validation checklist 100% checked
4. ✅ Error handling graceful for all error conditions
5. ✅ Context recovery works from any state

**When complete, you can confidently:**
- Use the protocol for real projects
- Extend it for your needs
- Trust the gates enforce quality
- Run autonomous multi-phase work

---

## Next Steps After Validation

**If all tests pass:**
1. Read README.md to understand use cases
2. Read PROTOCOL.md to understand execution
3. Create your own plan.yaml for a real project
4. Write phase briefs for your roadmap
5. Run your first autonomous phase

**If tests fail:**
1. Check Troubleshooting section above
2. Verify prerequisites installed
3. Open an issue: https://github.com/PM-Frontier-Labs/judge-gated-orchestrator/issues
4. Include error output and environment details

---

## Feedback

Found issues with this testing guide? Suggestions for additional tests?

Open an issue or PR: https://github.com/PM-Frontier-Labs/judge-gated-orchestrator

---

**Time to complete:** 15-20 minutes for full validation

**Difficulty:** Beginner (just follow steps)

**Result:** Confidence the protocol works as documented

===============================================================================
SECTION 2: CORE TOOLS (PYTHON)
===============================================================================

--- tools/judge.py ---
#!/usr/bin/env python3
"""
Judge: Evaluates a phase against plan gates.

Checks:
- Artifacts exist
- Tests pass
- Documentation updated
- LLM code review (if enabled)
"""

import sys
import time
from pathlib import Path
from typing import Dict, List, Any

try:
    import yaml
except ImportError:
    print("❌ Error: pyyaml not installed. Run: pip install pyyaml")
    sys.exit(1)

# Import shared utilities
from lib.git_ops import get_changed_files
from lib.scope import classify_files, check_forbidden_files
from lib.traces import check_gate_trace

# Import LLM judge (optional)
try:
    from llm_judge import llm_code_review
    LLM_JUDGE_AVAILABLE = True
except ImportError:
    LLM_JUDGE_AVAILABLE = False

REPO_ROOT = Path(__file__).parent.parent
REPO_DIR = REPO_ROOT / ".repo"
CRITIQUES_DIR = REPO_DIR / "critiques"
TRACES_DIR = REPO_DIR / "traces"


def load_plan() -> Dict[str, Any]:
    """Load plan.yaml and validate."""
    plan_file = REPO_DIR / "plan.yaml"
    if not plan_file.exists():
        print(f"❌ Error: {plan_file} not found")
        sys.exit(1)

    try:
        with plan_file.open() as f:
            return yaml.safe_load(f)
    except yaml.YAMLError as e:
        print(f"❌ Error: Invalid YAML in {plan_file}: {e}")
        sys.exit(1)


def get_phase(plan: Dict[str, Any], phase_id: str) -> Dict[str, Any]:
    """Get phase configuration from plan."""
    phases = plan.get("plan", {}).get("phases", [])
    for phase in phases:
        if phase.get("id") == phase_id:
            return phase
    raise ValueError(f"Phase {phase_id} not found in plan")


def check_artifacts(phase: Dict[str, Any]) -> List[str]:
    """Check that required artifacts exist."""
    issues = []
    artifacts = phase.get("artifacts", {}).get("must_exist", [])

    for artifact in artifacts:
        path = REPO_ROOT / artifact
        if not path.exists():
            issues.append(f"Missing required artifact: {artifact}")

    return issues




def check_docs(phase: Dict[str, Any]) -> List[str]:
    """Check that documentation was updated."""
    issues = []
    docs_gate = phase.get("gates", {}).get("docs", {})
    must_update = docs_gate.get("must_update", [])

    if not must_update:
        return issues

    # Check if docs exist and are not empty
    for doc in must_update:
        # Handle section anchors like "docs/mvp.md#feature"
        doc_path = doc.split("#")[0]
        path = REPO_ROOT / doc_path

        if not path.exists():
            issues.append(f"Documentation not found: {doc_path}")
        elif path.stat().st_size == 0:
            issues.append(f"Documentation is empty: {doc_path}")

    return issues




def check_drift(phase: Dict[str, Any], plan: Dict[str, Any]) -> List[str]:
    """Check for changes outside phase scope (plan drift)."""
    issues = []

    # Check if drift gate is enabled
    drift_gate = phase.get("gates", {}).get("drift")
    if not drift_gate:
        return []  # Drift checking not enabled for this phase

    # Get base branch
    base_branch = plan.get("plan", {}).get("base_branch", "main")

    # Get changed files
    changed_files = get_changed_files(
        REPO_ROOT,
        include_committed=True,
        base_branch=base_branch
    )

    if not changed_files:
        return []  # No changes or not a git repo

    # Get scope patterns
    scope = phase.get("scope", {})
    include_patterns = scope.get("include", [])
    exclude_patterns = scope.get("exclude", [])

    if not include_patterns:
        return []  # No scope defined, can't check drift

    # Classify files using shared utility
    in_scope, out_of_scope = classify_files(
        changed_files,
        include_patterns,
        exclude_patterns
    )

    # Check forbidden patterns using shared utility
    drift_rules = phase.get("drift_rules", {})
    forbid_patterns = drift_rules.get("forbid_changes", [])
    forbidden_files = check_forbidden_files(changed_files, forbid_patterns)

    if forbidden_files:
        issues.append("Forbidden files changed (these require a separate phase):")
        for f in forbidden_files:
            issues.append(f"  - {f}")
        issues.append(f"Fix: git checkout HEAD {' '.join(forbidden_files)}")
        issues.append("")

    # Check out-of-scope changes
    allowed_drift = drift_gate.get("allowed_out_of_scope_changes", 0)

    if len(out_of_scope) > allowed_drift:
        issues.append(f"Out-of-scope changes detected ({len(out_of_scope)} files, {allowed_drift} allowed):")
        for f in out_of_scope:
            issues.append(f"  - {f}")
        issues.append("")
        issues.append("Options to fix:")
        issues.append(f"1. Revert: git checkout HEAD {' '.join(out_of_scope)}")
        issues.append(f"2. Update phase scope in .repo/briefs/{phase['id']}.md")
        issues.append("3. Split into separate phase for out-of-scope work")

    return issues


def write_critique(phase_id: str, issues: List[str]):
    """Write a critique file."""
    critique_file = CRITIQUES_DIR / f"{phase_id}.md"
    critique_file.write_text(f"""# Critique: {phase_id}

## Issues Found

{chr(10).join(f"- {issue}" for issue in issues)}

## Resolution

Please address the issues above and re-run:
```
./tools/phasectl.py review {phase_id}
```
""")
    print(f"📝 Critique written to {critique_file.relative_to(REPO_ROOT)}")


def write_approval(phase_id: str):
    """Write an approval marker."""
    ok_file = CRITIQUES_DIR / f"{phase_id}.OK"
    ok_file.write_text(f"Phase {phase_id} approved at {time.time()}\n")
    print(f"✅ Approval written to {ok_file.relative_to(REPO_ROOT)}")


def judge_phase(phase_id: str):
    """Run all checks and produce verdict."""
    print(f"⚖️  Judging phase {phase_id}...")

    # Load plan
    plan = load_plan()

    try:
        phase = get_phase(plan, phase_id)
    except ValueError as e:
        print(f"❌ Error: {e}")
        return 2

    # Run all checks - Phase → Gates → Verdict
    all_issues = []

    print("  🔍 Checking artifacts...")
    all_issues.extend(check_artifacts(phase))

    print("  🔍 Checking tests...")
    all_issues.extend(check_gate_trace("tests", TRACES_DIR, "Tests"))

    # Lint check (optional)
    lint_gate = phase.get("gates", {}).get("lint", {})
    if lint_gate.get("must_pass", False):
        print("  🔍 Checking linting...")
        all_issues.extend(check_gate_trace("lint", TRACES_DIR, "Linting"))

    print("  🔍 Checking documentation...")
    all_issues.extend(check_docs(phase))

    print("  🔍 Checking for plan drift...")
    all_issues.extend(check_drift(phase, plan))

    # LLM code review (optional)
    if LLM_JUDGE_AVAILABLE:
        llm_gate = phase.get("gates", {}).get("llm_review", {})
        if llm_gate.get("enabled", False):
            print("  🤖 Running LLM code review...")
            all_issues.extend(llm_code_review(phase, REPO_ROOT))

    # Clean up old critiques/approvals
    for old_file in CRITIQUES_DIR.glob(f"{phase_id}.*"):
        old_file.unlink()

    # Verdict
    if all_issues:
        write_critique(phase_id, all_issues)
        return 1
    else:
        write_approval(phase_id)
        return 0


def main():
    if len(sys.argv) < 2:
        print("Usage: judge.py <PHASE_ID>")
        return 1

    phase_id = sys.argv[1]

    try:
        return judge_phase(phase_id)
    except Exception as e:
        print(f"❌ Judge error: {e}")
        import traceback
        traceback.print_exc()
        return 2


if __name__ == "__main__":
    sys.exit(main())

--- tools/phasectl.py ---
#!/usr/bin/env python3
"""
Phasectl: Controller for gated phase protocol.

Usage:
  ./tools/phasectl.py review <PHASE_ID>  # Submit phase for review
  ./tools/phasectl.py next                # Advance to next phase
"""

import sys
import json
import time
import subprocess
from pathlib import Path

try:
    import yaml
except ImportError:
    print("❌ Error: pyyaml not installed. Run: pip install pyyaml")
    sys.exit(1)

# Import shared utilities
from lib.git_ops import get_changed_files
from lib.scope import classify_files, check_forbidden_files
from lib.traces import run_command_with_trace

REPO_ROOT = Path(__file__).parent.parent
REPO_DIR = REPO_ROOT / ".repo"
CRITIQUES_DIR = REPO_DIR / "critiques"
TRACES_DIR = REPO_DIR / "traces"
BRIEFS_DIR = REPO_DIR / "briefs"
CURRENT_FILE = BRIEFS_DIR / "CURRENT.json"


def load_plan():
    """Load plan.yaml and validate."""
    plan_file = REPO_DIR / "plan.yaml"
    if not plan_file.exists():
        print(f"❌ Error: {plan_file} not found")
        sys.exit(1)

    try:
        with plan_file.open() as f:
            return yaml.safe_load(f)
    except yaml.YAMLError as e:
        print(f"❌ Error: Invalid YAML in {plan_file}: {e}")
        sys.exit(1)


def run_tests(plan):
    """Run tests and save results to trace file."""
    print("🧪 Running tests...")

    # Get test command from plan
    test_config = plan.get("plan", {}).get("test_command", {})
    if isinstance(test_config, str):
        test_cmd = test_config.split()
    elif isinstance(test_config, dict):
        test_cmd = test_config.get("command", "pytest tests/ -v").split()
    else:
        test_cmd = ["pytest", "tests/", "-v"]

    # Run command and save trace
    exit_code = run_command_with_trace("tests", test_cmd, REPO_ROOT, TRACES_DIR)

    if exit_code is None:
        print(f"❌ Error: {test_cmd[0]} not installed")
        print("   Install it or update test_command in .repo/plan.yaml")

    return exit_code


def run_lint(plan, phase_id):
    """Run linter and save results to trace file."""
    # Check if lint gate is enabled for this phase
    phases = plan.get("plan", {}).get("phases", [])
    phase = next((p for p in phases if p["id"] == phase_id), None)

    if not phase:
        return None

    lint_gate = phase.get("gates", {}).get("lint", {})
    if not lint_gate.get("must_pass", False):
        return None  # Lint not enabled for this phase

    print("🔍 Running linter...")

    # Get lint command from plan
    lint_config = plan.get("plan", {}).get("lint_command", {})
    if isinstance(lint_config, str):
        lint_cmd = lint_config.split()
    elif isinstance(lint_config, dict):
        lint_cmd = lint_config.get("command", "ruff check .").split()
    else:
        lint_cmd = ["ruff", "check", "."]

    # Run command and save trace
    exit_code = run_command_with_trace("lint", lint_cmd, REPO_ROOT, TRACES_DIR)

    if exit_code is None:
        print(f"❌ Error: {lint_cmd[0]} not installed")
        print("   Install it or update lint_command in .repo/plan.yaml")

    return exit_code




def show_diff_summary(phase_id: str, plan: dict):
    """Show summary of changed files vs phase scope."""
    # Get phase config
    phases = plan.get("plan", {}).get("phases", [])
    phase = next((p for p in phases if p["id"] == phase_id), None)

    if not phase:
        return  # Can't show summary without phase config

    # Get base branch
    base_branch = plan.get("plan", {}).get("base_branch", "main")

    # Get changed files using shared utility
    changed_files = get_changed_files(
        REPO_ROOT,
        include_committed=True,
        base_branch=base_branch
    )

    if not changed_files:
        print("📊 No changes detected")
        return

    # Get scope patterns
    scope = phase.get("scope", {})
    include_patterns = scope.get("include", [])
    exclude_patterns = scope.get("exclude", [])

    if not include_patterns:
        print(f"📊 {len(changed_files)} files changed (no scope defined)")
        return

    # Classify files using shared utility
    in_scope, out_of_scope = classify_files(
        changed_files,
        include_patterns,
        exclude_patterns
    )

    # Show summary
    print("📊 Change Summary:")
    print()

    if in_scope:
        print(f"✅ In scope ({len(in_scope)} files):")
        for f in in_scope[:10]:  # Show first 10
            print(f"  - {f}")
        if len(in_scope) > 10:
            print(f"  ... and {len(in_scope) - 10} more")
        print()

    if out_of_scope:
        print(f"❌ Out of scope ({len(out_of_scope)} files):")
        for f in out_of_scope:
            print(f"  - {f}")
        print()

        # Check drift gate
        drift_gate = phase.get("gates", {}).get("drift", {})
        allowed = drift_gate.get("allowed_out_of_scope_changes", 0)

        print(f"⚠️  Drift limit: {allowed} files allowed, {len(out_of_scope)} found")
        print()

        if len(out_of_scope) > allowed:
            print("💡 Fix options:")
            print(f"   1. Revert: git checkout HEAD {' '.join(out_of_scope[:3])}{'...' if len(out_of_scope) > 3 else ''}")
            print(f"   2. Update scope in .repo/briefs/{phase_id}.md")
            print("   3. Split into separate phase")
            print()

    # Check forbidden files using shared utility
    drift_rules = phase.get("drift_rules", {})
    forbid_patterns = drift_rules.get("forbid_changes", [])
    forbidden_files = check_forbidden_files(changed_files, forbid_patterns)

    if forbidden_files:
        print(f"🚫 Forbidden files changed ({len(forbidden_files)}):")
        for f in forbidden_files:
            print(f"  - {f}")
        print()
        print(f"   These require a separate phase. Revert: git checkout HEAD {' '.join(forbidden_files)}")
        print()


def review_phase(phase_id: str):
    """Submit phase for review and block until judge provides feedback."""
    print(f"📋 Submitting phase {phase_id} for review...")
    print()

    # Load plan
    plan = load_plan()

    # Show diff summary
    show_diff_summary(phase_id, plan)

    # Run tests
    test_exit_code = run_tests(plan)
    if test_exit_code is None:
        return 2  # Test runner not available

    # Run lint (if enabled for this phase)
    run_lint(plan, phase_id)
    # Note: Lint failures are checked by judge, not here

    # Trigger judge
    print("⚖️  Invoking judge...")
    subprocess.run(
        [sys.executable, REPO_ROOT / "tools" / "judge.py", phase_id],
        cwd=REPO_ROOT
    )

    # Check for critique or OK
    critique_file = CRITIQUES_DIR / f"{phase_id}.md"
    ok_file = CRITIQUES_DIR / f"{phase_id}.OK"

    if ok_file.exists():
        print(f"✅ Phase {phase_id} approved!")
        return 0
    elif critique_file.exists():
        print(f"❌ Phase {phase_id} needs revision:")
        print()
        print(critique_file.read_text())
        return 1
    else:
        print("⚠️  Judge did not produce feedback. Check for errors above.")
        return 2


def next_phase():
    """Advance to the next phase."""
    if not CURRENT_FILE.exists():
        print("❌ Error: No CURRENT.json found")
        return 1

    try:
        current = json.loads(CURRENT_FILE.read_text())
    except json.JSONDecodeError as e:
        print(f"❌ Error: Invalid JSON in {CURRENT_FILE}: {e}")
        return 1

    current_id = current.get("phase_id")
    if not current_id:
        print("❌ Error: No phase_id in CURRENT.json")
        return 1

    # Load plan
    plan = load_plan()
    phases = plan.get("plan", {}).get("phases", [])

    if not phases:
        print("❌ Error: No phases defined in plan.yaml")
        return 1

    # Find current phase
    current_idx = next((i for i, p in enumerate(phases) if p["id"] == current_id), None)

    if current_idx is None:
        print(f"❌ Error: Current phase {current_id} not found in plan")
        return 1

    # Check if current phase is approved
    ok_file = CRITIQUES_DIR / f"{current_id}.OK"
    if not ok_file.exists():
        print(f"❌ Error: Phase {current_id} not yet approved")
        print(f"   Run: ./tools/phasectl.py review {current_id}")
        return 1

    # Check if we're at the last phase
    if current_idx + 1 >= len(phases):
        print("🎉 All phases complete!")
        return 0

    # Advance to next phase
    next_phase_data = phases[current_idx + 1]
    next_id = next_phase_data["id"]
    next_brief = BRIEFS_DIR / f"{next_id}.md"

    if not next_brief.exists():
        print(f"❌ Error: Brief for {next_id} not found: {next_brief}")
        return 1

    # Update CURRENT.json
    CURRENT_FILE.write_text(json.dumps({
        "phase_id": next_id,
        "brief_path": str(next_brief.relative_to(REPO_ROOT)),
        "status": "active",
        "started_at": time.time()
    }, indent=2))

    print(f"➡️  Advanced to phase {next_id}")
    print(f"📄 Brief: {next_brief.relative_to(REPO_ROOT)}")
    return 0


def main():
    if len(sys.argv) < 2:
        print(__doc__)
        return 1

    command = sys.argv[1]

    if command == "review":
        if len(sys.argv) < 3:
            print("Usage: phasectl.py review <PHASE_ID>")
            return 1
        return review_phase(sys.argv[2])

    elif command == "next":
        return next_phase()

    else:
        print(f"Unknown command: {command}")
        print(__doc__)
        return 1


if __name__ == "__main__":
    sys.exit(main())

--- tools/llm_judge.py ---
#!/usr/bin/env python3
"""
LLM-based semantic code review for judge system.

Uses git diff to find actually changed files, then reviews them with Claude.
"""

import os
from typing import List, Dict, Any
from pathlib import Path

# Import shared utilities
from lib.git_ops import get_changed_files as get_changed_files_raw


def llm_code_review(phase: Dict[str, Any], repo_root: Path) -> List[str]:
    """
    Use Claude to review code quality semantically.

    Only reviews files that were actually changed (via git diff).
    """
    # Check if LLM review is enabled
    llm_gate = phase.get("gates", {}).get("llm_review", {})
    if not llm_gate.get("enabled", False):
        return []

    # Check API key
    api_key = os.getenv("ANTHROPIC_API_KEY")
    if not api_key:
        return ["LLM review enabled but ANTHROPIC_API_KEY not set in environment"]

    # Check anthropic package
    try:
        from anthropic import Anthropic
    except ImportError:
        return ["LLM review enabled but anthropic package not installed. Run: pip install anthropic"]

    # Get changed files (uncommitted only)
    changed_file_strs = get_changed_files_raw(
        repo_root,
        include_committed=False
    )

    # Convert to Path objects and filter to existing files
    changed_files = []
    for file_str in changed_file_strs:
        file_path = repo_root / file_str
        if file_path.exists() and file_path.is_file():
            changed_files.append(file_path)

    if not changed_files:
        # No changes detected - approve
        return []

    # Filter to only review code files (Python for now)
    code_files = [f for f in changed_files if f.suffix == ".py"]

    if not code_files:
        # No code files changed - approve
        return []

    # Build code context
    code_context = ""
    for file_path in code_files:
        try:
            code_context += f"\n{'='*60}\n"
            code_context += f"# File: {file_path.relative_to(repo_root)}\n"
            code_context += f"{'='*60}\n"
            code_context += file_path.read_text()
            code_context += "\n"
        except Exception:
            continue

    if not code_context:
        return []

    # Call Claude for review
    client = Anthropic(api_key=api_key)

    prompt = f"""You are a senior code reviewer. Review this code for phase: "{phase.get('description', 'unknown')}"

Changed files ({len(code_files)}):
{code_context}

Review criteria:
1. Architecture: Good design patterns? Well-structured?
2. Naming: Clear and consistent variable/function names?
3. Complexity: Simple and maintainable? Any overly complex logic?
4. Documentation: Complex parts explained? Adequate docstrings?
5. Edge cases: Errors handled properly? Edge cases covered?

Instructions:
- If you find issues, list each as "- Issue: [description]"
- Be specific: reference function names
- Focus on meaningful problems, not nitpicks
- If code is good quality, respond: "APPROVED - Code meets quality standards"
"""

    try:
        response = client.messages.create(
            model="claude-sonnet-4-20250514",
            max_tokens=2000,
            temperature=0,
            messages=[{"role": "user", "content": prompt}]
        )

        review_text = response.content[0].text.strip()

        # Parse response
        if "APPROVED" in review_text.upper():
            return []

        # Extract issues
        issues = []
        for line in review_text.split("\n"):
            line = line.strip()
            if line.startswith("- Issue:"):
                issue = line.replace("- Issue:", "").strip()
                issues.append(f"Code quality: {issue}")
            elif line.startswith("-") and len(line) > 2:
                # Handle variations
                issue = line[1:].strip()
                if issue:
                    issues.append(f"Code quality: {issue}")

        return issues

    except Exception as e:
        return [f"LLM review failed: {str(e)}"]

===============================================================================
SECTION 3: SHARED LIBRARIES
===============================================================================

--- tools/lib/__init__.py ---
"""
Shared utilities for judge-gated orchestrator.
"""

--- tools/lib/git_ops.py ---
"""Git operations for judge system."""

import subprocess
from pathlib import Path
from typing import List


def get_changed_files(
    repo_root: Path,
    include_committed: bool = True,
    base_branch: str = "main"
) -> List[str]:
    """Get changed files. If include_committed=False, only uncommitted changes."""
    try:
        all_changes = []

        # Always get uncommitted changes (staged and unstaged)
        result = subprocess.run(
            ["git", "diff", "--name-only", "HEAD"],
            cwd=repo_root,
            capture_output=True,
            text=True,
            check=True
        )
        uncommitted = [f for f in result.stdout.strip().split("\n") if f]
        all_changes.extend(uncommitted)

        # Optionally get committed changes from base branch
        if include_committed:
            # Get merge base
            result = subprocess.run(
                ["git", "merge-base", "HEAD", base_branch],
                cwd=repo_root,
                capture_output=True,
                text=True,
                check=True
            )
            merge_base = result.stdout.strip()

            # Get committed changes
            result = subprocess.run(
                ["git", "diff", "--name-only", f"{merge_base}...HEAD"],
                cwd=repo_root,
                capture_output=True,
                text=True,
                check=True
            )
            committed = [f for f in result.stdout.strip().split("\n") if f]
            all_changes.extend(committed)

        # Remove duplicates and empty strings
        unique_changes = list(set(all_changes))
        return [f for f in unique_changes if f]

    except subprocess.CalledProcessError:
        # Not a git repo or base branch doesn't exist
        return []

--- tools/lib/scope.py ---
"""File scope operations for drift checking."""

import fnmatch
from typing import List, Tuple


def matches_pattern(path: str, patterns: List[str]) -> bool:
    """Check if path matches any glob pattern."""
    return any(fnmatch.fnmatch(path, pattern) for pattern in patterns)


def classify_files(
    changed_files: List[str],
    include_patterns: List[str],
    exclude_patterns: List[str] = None
) -> Tuple[List[str], List[str]]:
    """Return (in_scope, out_of_scope) based on include/exclude patterns."""
    exclude_patterns = exclude_patterns or []
    in_scope = []
    out_of_scope = []

    for file_path in changed_files:
        included = matches_pattern(file_path, include_patterns)
        excluded = matches_pattern(file_path, exclude_patterns)

        if included and not excluded:
            in_scope.append(file_path)
        else:
            out_of_scope.append(file_path)

    return in_scope, out_of_scope


def check_forbidden_files(
    changed_files: List[str],
    forbid_patterns: List[str]
) -> List[str]:
    """Return files matching forbidden patterns."""
    if not forbid_patterns:
        return []
    return [f for f in changed_files if matches_pattern(f, forbid_patterns)]

--- tools/lib/traces.py ---
"""Trace file operations for gate commands."""

import time
import subprocess
from pathlib import Path
from typing import List, Optional


def run_command_with_trace(
    gate_name: str,
    command: List[str],
    repo_root: Path,
    traces_dir: Path
) -> Optional[int]:
    """
    Run command and save trace. Returns exit code or None if tool missing.
    """
    # Check if tool exists
    tool_name = command[0]
    version_cmd = ["ruff", "--version"] if tool_name == "ruff" else [tool_name, "--version"]

    try:
        subprocess.run(version_cmd, capture_output=True, check=True)
    except (subprocess.CalledProcessError, FileNotFoundError):
        return None

    # Run command
    result = subprocess.run(command, cwd=repo_root, capture_output=True, text=True)

    # Save trace
    traces_dir.mkdir(parents=True, exist_ok=True)
    trace_file = traces_dir / f"last_{gate_name}.txt"
    trace_file.write_text(
        f"Exit code: {result.returncode}\n"
        f"Timestamp: {time.time()}\n"
        f"\n=== STDOUT ===\n{result.stdout}\n"
        f"\n=== STDERR ===\n{result.stderr}\n"
    )

    return result.returncode


def check_gate_trace(gate_name: str, traces_dir: Path, error_prefix: str) -> List[str]:
    """Read trace and return issues if failed."""
    trace_file = traces_dir / f"last_{gate_name}.txt"

    if not trace_file.exists():
        return [f"No {gate_name} results found. {error_prefix} may not have run."]

    # Parse exit code
    for line in trace_file.read_text().split("\n"):
        if line.startswith("Exit code:"):
            try:
                exit_code = int(line.split(":")[1].strip())
                if exit_code == 0:
                    return []
                return [
                    f"{error_prefix} failed with exit code {exit_code}. "
                    f"See {trace_file.relative_to(trace_file.parent.parent.parent)} for details."
                ]
            except (ValueError, IndexError):
                pass

    return [f"Could not parse {gate_name} exit code from trace"]

===============================================================================
SECTION 4: TESTS
===============================================================================

--- tests/mvp/test_feature.py ---
"""
Tests for feature module.
"""

import pytest
import sys
from pathlib import Path

# Add src to path
sys.path.insert(0, str(Path(__file__).parent.parent.parent / "src"))

from mvp.feature import calculate_score


def test_calculate_score_positive():
    """Test calculate_score with positive values."""
    assert calculate_score(5) == 10
    assert calculate_score(100) == 200
    assert calculate_score(1) == 2


def test_calculate_score_zero():
    """Test calculate_score with zero."""
    assert calculate_score(0) == 0


def test_calculate_score_negative():
    """Test calculate_score with negative values."""
    assert calculate_score(-5) == -10
    assert calculate_score(-100) == -200


def test_calculate_score_type_validation():
    """Test that calculate_score validates input type."""
    with pytest.raises(TypeError):
        calculate_score("not an int")

    with pytest.raises(TypeError):
        calculate_score(3.14)

    with pytest.raises(TypeError):
        calculate_score(None)

--- tests/mvp/test_golden.py ---
"""
Golden path tests for MVP module.
"""

import sys
from pathlib import Path

# Add src to path
sys.path.insert(0, str(Path(__file__).parent.parent.parent / "src"))

from mvp import hello_world


def test_hello_world():
    """Test that hello_world returns the expected greeting."""
    result = hello_world()
    assert result == "Hello from MVP!"
    assert isinstance(result, str)
    assert len(result) > 0

===============================================================================
SECTION 5: CONFIGURATION
===============================================================================

--- .repo/plan.yaml ---
plan:
  id: MVP-DEMO
  summary: "Prove judge-gated phases with tests+docs."
  base_branch: "main"

  # Test command (optional, defaults to "pytest tests/ -v")
  test_command: "pytest tests/ -v"

  # Lint command (optional, defaults to "ruff check .")
  lint_command: "ruff check ."

  phases:
    - id: P01-scaffold
      description: "Create skeleton module + golden test + docs."
      scope:
        include: ["src/mvp/**", "tests/mvp/**", "docs/mvp.md"]
        exclude: ["src/**/legacy/**"]
      artifacts:
        must_exist: ["src/mvp/__init__.py", "tests/mvp/test_golden.py", "docs/mvp.md"]
      gates:
        tests: { must_pass: true }
        lint:  { must_pass: true }
        docs:  { must_update: ["docs/mvp.md"] }
        drift:
          allowed_out_of_scope_changes: 0
      drift_rules:
        forbid_changes: ["requirements.txt", "pyproject.toml"]

    - id: P02-impl-feature
      description: "Implement simple feature with refactor + doc section."
      scope:
        include: ["src/mvp/feature.py", "tests/mvp/test_feature.py", "docs/mvp.md"]
      artifacts:
        must_exist: ["src/mvp/feature.py", "tests/mvp/test_feature.py"]
      gates:
        tests: { must_pass: true }
        lint:  { must_pass: true }
        docs:  { must_update: ["docs/mvp.md#feature"] }
        llm_review: { enabled: true }
        drift:
          allowed_out_of_scope_changes: 0
      drift_rules:
        forbid_changes: ["requirements.txt", "pyproject.toml", ".github/**"]

--- .repo/briefs/P01-scaffold.md ---
# Phase P01: Scaffold

## Objective
Create the skeleton module structure with a golden test and initial documentation.

## Scope 🎯

✅ **YOU MAY TOUCH:**
- `src/mvp/**` - Module code
- `tests/mvp/**` - Test files
- `docs/mvp.md` - Documentation

❌ **DO NOT TOUCH:**
- `requirements.txt` - Dependencies (use separate phase)
- `pyproject.toml` - Project config (use separate phase)
- `src/**/legacy/**` - Legacy code (excluded)
- Other modules outside `mvp/`

🤔 **IF YOU NEED TO TOUCH THESE:**
Stop and create a separate phase. Drift prevention will fail the review.

## Required Artifacts
- [ ] `src/mvp/__init__.py` - Module initialization
- [ ] `tests/mvp/test_golden.py` - Golden path test
- [ ] `docs/mvp.md` - Initial documentation

## Gates
- **Tests:** Must pass
- **Docs:** Must update `docs/mvp.md`
- **Drift:** 0 out-of-scope changes allowed (enforced)

## Implementation Steps

1. **Create module structure**
   - Create `src/mvp/__init__.py` with basic module setup
   - Add a simple `hello_world()` function for testing

2. **Create golden test**
   - Create `tests/mvp/test_golden.py`
   - Write a test that validates `hello_world()` returns expected value
   - Ensure test passes

3. **Create documentation**
   - Create `docs/mvp.md`
   - Document the module purpose and basic API

4. **Submit for review**
   - Run: `./tools/phasectl.py review P01-scaffold`
   - Wait for judge feedback
   - If critique appears, fix issues and re-run review
   - When approved, run: `./tools/phasectl.py next`

## 4-Step Protocol

1. **Read** this brief and understand scope boundaries
2. **Implement** only files within the defined scope
3. **Review** via `./tools/phasectl.py review P01-scaffold`
4. **Iterate** until judge approves, then advance with `./tools/phasectl.py next`

--- .repo/briefs/P02-impl-feature.md ---
# Phase P02: Implement Feature

## Objective
Implement a simple feature with refactoring and documentation section.

## Scope 🎯

✅ **YOU MAY TOUCH:**
- `src/mvp/feature.py` - New feature module
- `tests/mvp/test_feature.py` - Feature tests
- `docs/mvp.md` - Update documentation

❌ **DO NOT TOUCH:**
- `requirements.txt` - Dependencies (use separate phase)
- `pyproject.toml` - Project config (use separate phase)
- `.github/**` - CI/CD config (use separate phase)
- Other modules outside this specific scope

🤔 **IF YOU NEED TO TOUCH THESE:**
Stop and create a separate phase. Drift prevention will fail the review.

## Required Artifacts
- [ ] `src/mvp/feature.py` - Feature implementation
- [ ] `tests/mvp/test_feature.py` - Feature tests

## Gates
- **Tests:** Must pass
- **Docs:** Must update `docs/mvp.md#feature` section
- **LLM Review:** Enabled (semantic code quality check)
- **Drift:** 0 out-of-scope changes allowed (enforced)

## Implementation Steps

1. **Create feature module**
   - Create `src/mvp/feature.py`
   - Implement a `calculate_score(value: int) -> int` function
   - Function should validate input and return value * 2

2. **Create feature tests**
   - Create `tests/mvp/test_feature.py`
   - Test valid inputs (positive, zero, negative)
   - Test edge cases
   - Ensure all tests pass

3. **Update documentation**
   - Add a "## Feature" section to `docs/mvp.md`
   - Document the `calculate_score` function
   - Include usage examples

4. **Submit for review**
   - Run: `./tools/phasectl.py review P02-impl-feature`
   - Wait for judge feedback
   - If critique appears, fix issues and re-run review
   - When approved, pipeline is complete!

## 4-Step Protocol

1. **Read** this brief and understand scope boundaries
2. **Implement** only files within the defined scope
3. **Review** via `./tools/phasectl.py review P02-impl-feature`
4. **Iterate** until judge approves, then complete

--- requirements.txt ---
pytest>=7.0.0
pyyaml>=6.0
anthropic>=0.39.0
ruff>=0.1.0

--- .gitignore ---
# Python
__pycache__/
*.py[cod]
*$py.class
*.so
.Python
build/
develop-eggs/
dist/
downloads/
eggs/
.eggs/
/lib/
/lib64/
parts/
sdist/
var/
wheels/
*.egg-info/
.installed.cfg
*.egg

# Virtual environments
venv/
ENV/
env/

# IDE
.vscode/
.idea/
*.swp
*.swo
*~

# Testing
.pytest_cache/
.coverage
htmlcov/

# Runtime files
.repo/critiques/*.md
.repo/critiques/*.OK
.repo/traces/*.txt

# Environment variables
.env

===============================================================================
SECTION 6: EXAMPLE CODE
===============================================================================

--- src/mvp/feature.py ---
"""
Feature module - Score calculation functionality.
"""


def calculate_score(value: int) -> int:
    """
    Calculate a score by doubling the input value.

    Args:
        value: Input integer value to calculate score from

    Returns:
        int: The calculated score (value * 2)

    Raises:
        TypeError: If value is not an integer
    """
    if not isinstance(value, int):
        raise TypeError(f"Expected int, got {type(value).__name__}")

    return value * 2

===============================================================================
SECTION 7: PROJECT STRUCTURE
===============================================================================

Directory tree:
/tmp/package_all.sh: line 167: tree: command not found

===============================================================================
SECTION 8: USAGE GUIDE
===============================================================================

## Quick Start

1. Setup:
   ```bash
   mkdir myproject
   cd myproject
   git init
   
   # Create structure
   mkdir -p .repo/briefs .repo/critiques .repo/traces
   mkdir -p tools/lib
   mkdir -p tests src
   
   # Copy files from this package to appropriate locations
   ```

2. Install dependencies:
   ```bash
   pip install -r requirements.txt
   ```

3. Create your first phase:
   ```bash
   # Edit .repo/plan.yaml with your phases
   # Write .repo/briefs/P01-yourphase.md
   # Set CURRENT.json to point to P01
   ```

4. Execute:
   ```bash
   ./tools/phasectl.py review P01-yourphase
   ```

## Key Files

- `tools/judge.py` (267 LOC): Gate validation logic
- `tools/phasectl.py` (327 LOC): Review orchestration
- `tools/llm_judge.py` (129 LOC): Optional LLM review
- `tools/lib/git_ops.py` (57 LOC): Git operations
- `tools/lib/scope.py` (41 LOC): File scope classification
- `tools/lib/traces.py` (64 LOC): Command trace handling

Total: 888 LOC

## Configuration

Edit `.repo/plan.yaml` to define:
- Phases (id, description, scope, gates)
- Test command
- Lint command
- Base branch for drift detection

## Gates

All gates return List[str] (empty = pass, items = issues):

- `check_artifacts()`: Required files exist
- `check_gate_trace("tests")`: Tests passed (reads trace)
- `check_gate_trace("lint")`: Linting passed (reads trace)
- `check_docs()`: Documentation updated
- `check_drift()`: Changes within scope
- `llm_code_review()`: Claude semantic review (optional)

## Extending

Add new gates:
1. Write check function: `def check_security(phase) -> List[str]`
2. Add to judge.py gate checks
3. Add gate config to plan.yaml

## Philosophy

This is a PROTOCOL, not a framework.
- No classes to inherit
- No packages to import
- Just files following conventions
- Shell commands to orchestrate

Like Git doesn't dictate code structure, this doesn't dictate architecture.
It only enforces quality during autonomous execution.

===============================================================================
END OF PACKAGE
===============================================================================
